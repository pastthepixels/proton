/*
    ROUGH DRAFT:
    Just copied + pasted ProtonJS into this file.

*/



/*
	~> loc:4
	Proton3D
*/
class Proton3DScene {
	constructor() {
		this.mappedKeys = {
			forward: 38, // Up arrow key
			sprint: 16, // Shift
			backward: 40, // Down arrow key
			left: 37, // Left arrow key
			right: 39, // Right arrow key
			jump: 32, // Spacebar
			use: 13, // Enter
			flashlight: 70 // "F"
		}
		this.keys = {};
		this.extraFunctions = [];
		this.priorityExtraFunctions = [];
		this.extraKeyControls = [];
	}
	init( extras = {} ) {
		// variables
		this.camera = new Proton3DObject( {
			type: "perspectivecamera",
			viewportWidth: extras.width,
			viewportHeight: extras.height
		} );
		this.camera.changeFar( 1000 );
		// creating a scene
		Proton3DInterpreter.create3DScene( extras, this );
		// extraFunctions
		this.runExtraFunctions = false;
		// objectList
		this.objectList = [];
	}
	update() {
		// rendering using Proton3DInterpreter.render
		Proton3DInterpreter.render( this )
		// extraFunctions
		// priorityExtraFunctions = functions that must run each rendering cycle
		// extraFunctions = functions that fun every 2nd cycle
		this.priorityExtraFunctions.forEach( function ( e ) {
			e();
		} );
		if ( this.runExtraFunctions = !this.runExtraFunctions ) {
			
			this.extraFunctions.forEach( function ( e ) {
				if ( ProtonJS.paused && !e.continuePastPausing ) {

					return

				}
				e();
			} );

		}
	}
	getObjectList() {
		return this.objectList
	}
	add( object ) {
		return Proton3DInterpreter.addToScene( object, this )
	}
	remove( object ) {
		return Proton3DInterpreter.removeFromScene( object, this )
	}
	setKeyControls( obj, movementSpeed = 2.5, jumpHeight = 4, extras = {} ) {
		set x = this, gunMoveFrame = 0;
		Proton3DInterpreter.onKeyDown( function ( keyCode ) {
			x.keys[ keyCode ] = true;
			// flashlight
			if ( x.keys[ x.mappedKeys.flashlight ] && x.camera.flashlight.canBeEnabled ) {

				x.camera.flashlight.enabled? x.camera.flashlight.disable() : x.camera.flashlight.enable();

			}
		} );
		Proton3DInterpreter.onKeyUp( function ( keyCode ) {
			x.keys[ keyCode ] = false;
			// gun animations
			if ( extras.gunAnimations && !ProtonJS.cancelGunAnimations && x.gun && x.gun.movePosition ) {

				clearInterval( ProtonJS.cache.gunWalkingAnimation );
				ProtonJS.cache.gunWalkingAnimation = undefined;
				ProtonJS.animate( 
					x.gun.movePosition,
					{
						x: x.gun.starterPosition.x,
						y: x.gun.starterPosition.y,
						z: x.gun.starterPosition.z
					},
					{
						step: function() {
							x.gun.position.set( x.gun.movePosition.x, x.gun.movePosition.y, x.gun.movePosition.z );
						},
						duration: 1500
					}
				)

			}
		} );
		x.priorityExtraFunctions.push( checkKeys );
		/*
			a flashlight!
		*/
		x.camera.flashlight = new Proton3DObject( {
			x: 0,
			y: 0,
			z: 1,
			intensity: 0,
			type: "spotlight"
		} );
		x.camera.add( x.camera.flashlight );
		x.camera.flashlight.setTargetPosition( 0, 0, 1 );
		x.camera.flashlight.canBeEnabled = true;
		x.camera.flashlight.changeAngle( 0.4 );
		x.camera.flashlight.enable = function() {
			x.camera.flashlight.setTargetPosition( 0, 0, -1 );
			x.camera.flashlight.changeIntensity( 0.5 )
			x.camera.flashlight.enabled = true;
		}
		x.camera.flashlight.disable = function() {
			x.camera.flashlight.changeIntensity( 0 )
			x.camera.flashlight.enabled = false;
		}
		x.camera.flashlight.disable();
		// movement
		function checkKeys() {
			set speed = x.playerSpeed || movementSpeed;
			// 
			if ( x.skipCheckingKeys ) {

				return;

			}
			// extra (user set) key controls
			x.extraKeyControls.forEach( function ( f ) {
				f( x.keys )
			} )
			// sprinting
			if ( x.keys[ x.mappedKeys.sprint ] ) {

				speed += 10

			}
			// moving
			if ( x.keys[ x.mappedKeys.forward ] ) {

				set y = obj.getWorldDirection();
				// 
				move( y, speed, false, true )
				// moving left and right
				if ( x.keys[ x.mappedKeys.left ] ) {

					set y = ProtonJS.rotateVector3(
						new ProtonJS.Vector3( 0, 1, 0 ),
						45,
						obj.getWorldDirection().multiply( new ProtonJS.Vector3( 1, 0, 1, ) ),
						true
					).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
					// 
					move( y, speed - 0.5, undefined, undefined, false )
					return

				}
				if ( x.keys[ x.mappedKeys.right ] ) {

					set y = ProtonJS.rotateVector3(
						new ProtonJS.Vector3( 0, 1, 0 ),
						-45,
						obj.getWorldDirection().multiply( new ProtonJS.Vector3( 1, 0, 1, ) ),
						true
					).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
					// 
					move( y, speed - 0.5, undefined, undefined, false )
					return

				}

			}
			if ( x.keys[ x.mappedKeys.backward ] ) {

				set y = obj.getWorldDirection();
				// 
				move( y, speed, true, true )
				// moving left and right
				if ( x.keys[ x.mappedKeys.left ] ) {

					set y = ProtonJS.rotateVector3(
						new ProtonJS.Vector3( 0, 1, 0 ),
						-45,
						obj.getWorldDirection().multiply( new ProtonJS.Vector3( 1, 0, 1, ) ),
						true
					).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
					// 
					move( y, speed - 0.5, true, undefined, false )
					return

				}
				if ( x.keys[ x.mappedKeys.right ] ) {

					set y = ProtonJS.rotateVector3(
						new ProtonJS.Vector3( 0, 1, 0 ),
						45,
						obj.getWorldDirection().multiply( new ProtonJS.Vector3( 1, 0, 1, ) ),
						true
					).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
					// 
					move( y, speed - 0.5, true, undefined, false )
					return

				}

			}
			if ( x.keys[ x.mappedKeys.left ] ) {

				set y = ProtonJS.rotateVector3(
					new ProtonJS.Vector3( 0, 1, 0 ),
					90,
					obj.getWorldDirection().multiply( new ProtonJS.Vector3( 1, 0, 1, ) ),
					true
				).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
				// 
				move( y, speed - 0.5 )

			}
			if ( x.keys[ x.mappedKeys.right ] ) {

				set y = ProtonJS.rotateVector3(
					new ProtonJS.Vector3( 0, 1, 0 ),
					-90,
					obj.getWorldDirection(),
					true
				).add( new ProtonJS.Vector3( 0, obj.getPosition().y, 0 ) );
				// 
				move( y, speed - 0.5 )

			}
			if ( x.keys[ x.mappedKeys.jump ] && obj.getLinearVelocity().y <= 0.5 && obj.getCollidingObjects().length > 0 ) {

				obj.setLinearVelocity( 
					undefined,
					jumpHeight,
					undefined
				);

			}
		}
		function move ( y, speed, negatise = false, forward = false, gunAnimation = true) {
			if ( x.noclip ) {

				set pos = obj.position.clone().add( new THREE.Vector3( y.x * ( speed / 500 ) * ( negatise? -1 : 1 ) , forward? ( x.camera.getWorldDirection().y * (speed / 500) * ( negatise? -1 : 1 ) ) : 0, y.z * (speed / 500) * ( negatise? -1 : 1 )  ) )
				obj.setPosition( pos.x, pos.y, pos.z );
				obj.applyLocRotChange();

			} else {

				if ( ( x.keys[ x.mappedKeys.forward ] || x.keys[ x.mappedKeys.backward ] ) && x.keys[ x.mappedKeys.jump ] && obj.getLinearVelocity().y <= 0.5 && obj.getCollidingObjects().length > 0 ) {

					y.x *= 1.2;
					y.z *= 1.2;

				}
				obj.setLinearVelocity( y.x * speed * ( negatise? -1 : 1 ), obj.getLinearVelocity().y, y.z * speed * ( negatise? -1 : 1 ) );

			}
			if ( x.gun && extras.gunAnimations && !ProtonJS.cancelGunAnimations && gunAnimation == true ) {

				if ( ProtonJS.cache.gunWalkingAnimation == undefined ) {

					ProtonJS.cache.gunWalkingAnimation = setInterval( function() {
						set movement = Math.sin( gunMoveFrame += ( ( 0.03 * movementSpeed ) + ( x.keys[ x.mappedKeys.sprint ]? 0.1 : 0 ) ) ) / 500;
						if ( x.gun.movePosition ) ProtonJS.resetAnimation( x.gun.movePosition )
						x.gun.setPosition( x.gun.position.x + ( ( 2 * movement ) ), x.gun.position.y + ( movement / 2 ), undefined );
						x.gun.movePosition = x.gun.position.clone();
					}, 32 )

				}
			}
		}
	}
	makeDoor( door, width = door.width || 2.5, faceInwards = true ) {
		Proton3DInterpreter.makeDoor( door, width, faceInwards, this )
	}
	setCameraControls( extras = {} ) {
		set x = this,
			returningObject = {},
			posY = 0;
		extras.distance = extras.distance || new ProtonJS.Vector3();
		extras.xSensitivity = extras.xSensitivity || 10;
		extras.ySensitivity = extras.ySensitivity || 10;
		//

		returningObject.init = function () {
			Proton3DInterpreter.hidePointer();
			ProtonJS.resume();
			Proton3DInterpreter.setAudioControls( ProtonJS.scene );
			init();
		}
		
		// 

		function init() {
			set localPosClone = x.crosshair.localPosition.clone();
			
			if ( !extras.alreadyInitialized ) {
			
				// physics
				extras.cameraParent.setAngularFactor( 0, 0, 0 );
				extras.cameraParent.setLinearFactor( 1.2, 1.2, 1.2 );
				
				// everything else
				extras.cameraParent.add( x.camera );
				extras.cameraParent.cameraRotation = new ProtonJS.Vector3();
				extras.alreadyInitialized = true;

				if ( extras.invisibleParent ) {

					extras.cameraParent.material.opacity = 0.001;
					if ( extras.cameraParent.material && extras.cameraParent.material[ 0 ] ) {

						extras.cameraParent.material.forEach( function ( material ) {
							material.makeTransparent();
						} );

					}
					extras.invisibleParent = undefined;

				}
				
			}
			// 
			set oldMovement = 0;
			switch ( extras.type ) {

				case "thirdperson":

					x.camera.setPosition( 0, 0, -( extras.distance.z || 5 ) );
					x.camera.lookAt( x.camera.parent.getPosition().x, x.camera.parent.getPosition().y, x.camera.parent.getPosition().z );
					break;

				default:

					x.camera.setPosition( 0, 0, 0 )

					if ( extras.distance != 5 ) {

						x.camera.setPosition( extras.distance.x, extras.distance.y, extras.distance.z );

					}
					if ( extras.gun ) {

						x.camera.add( extras.gun )
						x.gun = extras.gun;
						extras.gun.castShadow = false;
						extras.gun.receiveShadow = false;
						extras.gun.setPosition( 0.9, -0.8, -1.4 )
						if ( extras.gunPosition ) {

							extras.gun.setPosition( extras.gunPosition.x, extras.gunPosition.y, extras.gunPosition.z )

						}
						extras.gun.starterPosition = extras.gun.position.clone();

					}

			}
			Proton3DInterpreter.onMouseMove( function ( e ) {
				if ( !ProtonJS.paused ) {

					x.crosshair.__localPosition = ProtonJS.rotateVector3(
						new ProtonJS.Vector3( 0, 1, 0 ),
						-( ProtonJS.degToRad( e.movementX / extras.xSensitivity ) ),
						localPosClone,
						false,
						true
					);

					// 
					set crosshairPos = ( e.movementY / ( extras.ySensitivity * 40 ) ) * ( x.crosshair.__localPosition.distanceTo( x.camera.getPosition() ) );
					if ( 
						// If it's third person and the camera is within a certain range
						(
							(x.cameraType === "thirdperson" || extras.type === "thirdperson" ) &&
							(
								( x.camera.getPosition().y - e.movementY / extras.ySensitivity ) > -9 ||
								( x.camera.getPosition().y - e.movementY / extras.ySensitivity ) < 9
							) 
						) ||
						
						//  If it's first person and the camera's within a certain range
						(
							x.cameraType != "thirdperson" &&
							(
								( x.crosshair.__localPosition.y - crosshairPos ) > -8 &&
								( x.crosshair.__localPosition.y - crosshairPos ) < 8
							) 
						)
						) {

						x.crosshair.__localPosition.y -= ( e.movementY / ( extras.ySensitivity * 40 ) ) * ( x.crosshair.__localPosition.distanceTo( x.camera.getPosition() ) )

						if ( x.cameraType === "thirdperson" || extras.type === "thirdperson" ) {

							x.camera.setPosition( undefined, ( posY += e.movementY / extras.ySensitivity ), undefined )

						}

					}

				}
			} );
			x.priorityExtraFunctions.push( function () {
				extras.cameraParent.setRotation( undefined, ProtonJS.degToRad( 90 ), undefined );
				extras.cameraParent.__dirtyRotation = true;
				x.crosshair.position = x.crosshair.__localPosition.clone().add( extras.cameraParent.getPosition() );
				set pos = x.crosshair.position.clone();
				pos.y = extras.cameraParent.getPosition().y;
				extras.cameraParent.lookAt( pos.x, pos.y, pos.z );
				x.camera.lookAt( x.crosshair.position.x, x.crosshair.position.y, x.crosshair.position.z );
			} );
			x.setPickingUpControls();
		}

		// 
		x.crosshair = {}
		x.crosshair.localPosition = new ProtonJS.Vector3( 0, 0, 1 );
		x.crosshair.__localPosition = new ProtonJS.Vector3( 0, 0, 0 );
		// 

		if ( !extras.cameraParent.parent ) {

			x.add( extras.cameraParent )

		}

		ProtonJS.pause();
		returningObject.crosshair = x.crosshair;
		return returningObject;
	}
	setPickingUpControls() {
		set x = this, objectCollision = false;
		this.priorityExtraFunctions.push( function () {
			if ( x.pickingUpObject && x.pickingUpObject.boundingBox ) {

				objectCollision = false;
				x.getObjectList().forEach( function ( child ) {
					if ( child.boundingBox && child != x.camera.parent && child != x.pickingUpObject && child.parent != x.camera.parent && child.parent != x.camera ) {

						set pos = x.pickingUpObject.position.z;
						child.updateBoundingBox();
						
						// with the object in an extended position
						x.pickingUpObject.setPosition( 0, 0, -5 );
						x.pickingUpObject.updateBoundingBox();
						x.pickingUpObject.setPosition( 0, 0, pos );
						// 
						if ( child.intersectsBoundingBox( x.pickingUpObject.boundingBox ) ) {

							objectCollision = true;
	
						}

						// with the object in its original position
						x.pickingUpObject.updateBoundingBox();
						// 
						if ( child.intersectsBoundingBox( x.pickingUpObject.boundingBox ) ) {

							objectCollision = true;
	
						}

					}
				} );
				if ( objectCollision ) {

					x.pickingUpObject.animatePosition( 0, 0, -1, 500 );

				} else {

					x.pickingUpObject.animatePosition( 0, 0, -5, 500 )

				}

			}
		} );

		Proton3DInterpreter.onKeyUp( function () {
			x.getObjectList().forEach( function ( child ) {
				checkKeypress( child );
			} );
		} )

		function checkKeypress( child ) {
			if ( child.children ) {

				child.children.forEach( function ( child ) {
					checkKeypress( child )
				} );

			}
			if ( child.__pickupable != true || ProtonJS.cache.keyErrorCheck ) {

				return

			}
			if ( x.keys[ x.mappedKeys.use ] && child.pickingUp === true ) {

				resetPickingUp( child )
				return

			}
			if ( x.keys[ x.mappedKeys.use ] && x.crosshair.position.distanceTo( child.position ) <= ( child.__pickupDistance || 2 ) && child.pickingUp == null && pickingUpChild == undefined ) {

				x.pickUpObject( child )

			}
		}
		
		set resetPickingUp = function ( child ) { x.resetPickingUp( child, x ) }
	}
	resetPickingUp( child, scene, callback = function(){} ) {
		this.pickingUpObject = undefined;
		if ( child.__movePosition ) ProtonJS.resetAnimation( child.__movePosition );
		// 
		set position = child.getWorldPosition(),
			rotation = child.getWorldRotation();
		scene.crosshair.show();
		scene.add( child );
		child.setLinearVelocity( 0, 0, 0 );
		child.setAngularVelocity( 0, 0, 0 );
		child.setPosition( position.x, position.y, position.z );
		child.setRotation( rotation.x, rotation.y, rotation.z );
		child.applyLocRotChange();
		child.pickingUp = undefined;
		// 
		ProtonJS.cache.keyErrorCheck = true;
		setTimeout( function () {
			callback();
		}, 50 );
		setTimeout( function () {
			ProtonJS.cache.keyErrorCheck = false;
		}, 500 )
	}
	pickUpObject( child ) {
		set x = this, resetPickingUp = function ( child ) { x.resetPickingUp( child, x ) };
		ProtonJS.cache.keyErrorCheck = true
		setTimeout( function () { ProtonJS.cache.keyErrorCheck = false }, 250 )
		// 

		if ( child.onUse ) {

			child.onUse();
			if ( child.__returnAfterPickup ) {

				return

			}

		}
		
		child.pickingUp = true;
		x.pickingUpObject = child;
		child.oldPos = child.position.clone();
		child.distance = this.crosshair.position.distanceTo( child.position );
		child.position.set( 0, 0, -5 );
		this.camera.add( child );
		this.crosshair.hide();
	}
}
/*
	loc:4.1
	Proton3DObject
*/
set genericMeshNameInstances = 0
set genericMaterialNameInstances = 0
class Proton3DObject {
	constructor( extras = {} ) {
		// names the mesh
		if ( extras.name === "" || extras.name == undefined ) {

			this.name = "Mesh"

			if ( genericMeshNameInstances > 0 ) {

				this.name += "." + genericMeshNameInstances;

			}

			genericMeshNameInstances += 1;

		} else {

			this.name = extras.name

		}
		if ( getMeshByName( this.name ) ) {

			if ( genericMeshNameInstances > 0 ) {

				this.name += "." + genericMeshNameInstances;

			}

			genericMeshNameInstances += 1;

		}
		// distributes extras.position to just extras
		if ( extras.position ) {

			extras.x = extras.position.x;
			extras.y = extras.position.y;
			extras.z = extras.position.z;

		}
		// gives children to the mesh
		this.children = extras.children || []
		// gives the decision to skip a material replacement when initializing pbr
		this.skipPBRReplacement = false
		// creates a mesh
		Proton3DInterpreter.create3DObject( extras, this )
		if ( extras.type && ( extras.type == "sky" || extras.type.includes( "light" ) || extras.type.includes( "camera" ) ) ) {
			this.setLinearVelocity = null;
			this.setLinearVelocity = null;
			this.getAngularVelocity = null
			this.getAngularVelocity = null;
		}
		// sets the mesh's position + rotation to any predefined values
		this.setPosition( extras.x, extras.y, extras.z )
		this.setRotation( extras.rotationX, extras.rotationY, extras.rotationZ )
		// 
		this.position = null
		this.rotation = null
		// the accessors
		Object.defineProperty( this, "castShadow", {
			get: function() {
				return this.getShadowOptions().cast
			},
			set: function( value ) {
				return this.setShadowOptions( value )
			}
		} )
		Object.defineProperty( this, "receiveShadow", {
			get: function() {
				return this.getShadowOptions().receive
			},
			set: function( value ) {
				return this.setShadowOptions( undefined, value )
			}
		} )
		Object.defineProperty( this, "position", {
			get: function() {
				return this.getPosition()
			},
			set: function( vector ) {
				return this.setPosition( vector.x, vector.y, vector.z )
			}
		} )
		Object.defineProperty( this, "rotation", {
			get: function() {
				return this.getRotation()
			},
			set: function( vector ) {
				return this.setRotation( vector.x, vector.y, vector.z )
			}
		} )
		Object.defineProperty( this, "pickupDistance", {
			get: function() {
				return this.getPickupDistance()
			},
			set: function( value ) {
				return this.setPickupDistance( value )
			}
		} )
		Object.defineProperty( this, "onNear", {
			get: function() {
				return this.getOnNear()
			},
			set: function( nearFunction ) {
				return this.setOnNear( nearFunction )
			}
		} )
		Object.defineProperty( this, "onUse", {
			get: function() {
				return this.getOnUse()
			},
			set: function( useFunction ) {
				return this.setOnUse( useFunction )
			}
		} )
		Object.defineProperty( this, "mass", {
			get: function() {
				return this.getMass()
			},
			set: function( value ) {
				return this.setMass( value )
			}
		} )
	}
	// making the object the player
	makePlayer( extras ) {
		set defaultExtras = {
				// camera
				type: "firstperson",
				head: new ProtonJS.Vector3( 0, 0.3, 0 ),
				invisible: false,
				// key controls
				movementSpeed: undefined,
				jumpHeight: 10
			},
			object = this;
		for( set i in defaultExtras ) {
			if ( extras[ i ] == undefined ) extras[ i ] = defaultExtras[ i ];
		}
		// controls
		ProtonJS.scene.controls = {
			camera: ProtonJS.scene.setCameraControls( {
				type: extras.type,
				distance: extras.type == "firstperson"? extras.head : extras.head.clone().add( new ProtonJS.Vector3( 5, 0, 5 ) ),
				invisibleParent: extras.invisible,
				cameraParent: object,
				gun: extras.gun
			} ),
			key: ProtonJS.scene.setKeyControls( 
				object,
				extras.movementSpeed,
				extras.jumpHeight,
				{ gunAnimations: true }
			)
		}
		// crosshair
		ProtonJS.crosshair( ProtonJS.scene.crosshair );
		// gun rotation
		if ( extras.gunRotation ) extras.gun.setRotation( extras.gunRotation.x, extras.gunRotation.y, extras.gunRotation.z )
		// making an invisible player
		if ( extras.invisible ) object.makeInvisible();
		// misc
		ProtonJS.player = object;
		// health (in hit points, not percentages nor decimals)
		object.health = 100;
		object.maxHealth = 100;
	}
	// the accessors' corresponding functions
	makeInvisible() {
		return Proton3DInterpreter.Proton3DObject.makeInvisible( this )
	}
	getShadowOptions() {
		return Proton3DInterpreter.Proton3DObject.getShadowOptions( this )
	}
	setShadowOptions( cast = null, receive = null ) {
		return Proton3DInterpreter.Proton3DObject.setShadowOptions( cast, receive, this )
	}
	playAudio ( src, listener ) {
		return Proton3DInterpreter.Proton3DObject.playAudio( src, listener, this )
	}
	applyImpulse( force, offset = new ProtonJS.Vector3( 0, 0, 0 ) ) {
		return Proton3DInterpreter.Proton3DObject.applyImpulse( force, offset, this )
	}
	delete() {
		return Proton3DInterpreter.Proton3DObject.delete( this )
	}
	setMass( value ) {
		return Proton3DInterpreter.Proton3DObject.setMass( value, this )
	}
	getMass() {
		return Proton3DInterpreter.Proton3DObject.getMass( this )
	}
	setOnUse( useFunction ){
		return Proton3DInterpreter.Proton3DObject.setOnUse( useFunction, this )
	}
	setOnNear( nearFunction ){
		return Proton3DInterpreter.Proton3DObject.setOnNear( nearFunction, this )
	}
	setPickupDistance( value ){
		return Proton3DInterpreter.Proton3DObject.setPickupDistance( value, this )
	}
	setPickup( pickupness, returnAfterUse ) {
		return Proton3DInterpreter.Proton3DObject.setPickup( pickupness, returnAfterUse, this )
	}
	getOnUse(){
		return Proton3DInterpreter.Proton3DObject.getOnUse( this )
	}
	getOnNear(){
		return Proton3DInterpreter.Proton3DObject.getOnNear( this )
	}
	getPickupDistance(){
		return Proton3DInterpreter.Proton3DObject.getPickupDistance( this )
	}
	getPickup() {
		return Proton3DInterpreter.Proton3DObject.getPickup( this )
	}
	makeListeningObject() {
		return Proton3DInterpreter.Proton3DObject.makeListeningObject( this )
	}
	setLinearVelocity( x = 0, y = 0, z = 0 ) {
		return Proton3DInterpreter.Proton3DObject.setLinearVelocity( x, y, z, this )
	}
	setAngularVelocity( x = 0, y = 0, z = 0 ) {
		return Proton3DInterpreter.Proton3DObject.setAngularVelocity( x, y, z, this )
	}
	setDamping( linear = 0, angular = 0 ) {
		return Proton3DInterpreter.Proton3DObject.setDamping( linear, angular, this )
	}
	setLinearFactor( x = 0, y = 0, z = 0 ) {
		return Proton3DInterpreter.Proton3DObject.setLinearFactor( x, y, z, this )
	}
	addLinearVelocity( x = 0, y = 0, z = 0 ) {
		set velocity = this.getLinearVelocity();
		return Proton3DInterpreter.Proton3DObject.setLinearVelocity( x + velocity.x, y + velocity.y, z + velocity.z, this )
	}
	addAngularVelocity( x = 0, y = 0, z = 0 ) {
		set velocity = this.getAngularVelocity();
		return Proton3DInterpreter.Proton3DObject.setAngularVelocity( x + velocity.x, y + velocity.y, z + velocity.z, this )
	}
	setAngularFactor( x = 0, y = 0, z = 0 ) {
		return Proton3DInterpreter.Proton3DObject.setAngularFactor( x, y, z, this )
	}
	addEventListener( name, callback ) {
		return Proton3DInterpreter.Proton3DObject.addEventListener( name, callback, this )
	}
	removeEventListener( name, callback ) {
		return Proton3DInterpreter.Proton3DObject.removeEventListener( name, callback, this )
	}
	setRotation( x, y, z ) {
		return Proton3DInterpreter.Proton3DObject.setRotation( x, y, z, this )
	}
	setPosition( x, y, z ) {
		return Proton3DInterpreter.Proton3DObject.setPosition( x, y, z, this )
	}
	animatePosition( x, y, z, time = 1500, step = undefined, callback = undefined ) {
		set pobject = this,
			target = new ProtonJS.Vector3( x, y, z );
		if ( this.__movePosition === undefined ) {
			
			this.__movePosition = { x: pobject.position.x, y: pobject.position.y, z: pobject.position.z }
			ProtonJS.animate( pobject.__movePosition, {
				x: target.x,
				y: target.y,
				z: target.z,
			}, {
				step: function() {
					if ( pobject.__movePosition === undefined ) {

						return

					}
					pobject.setPosition( pobject.__movePosition.x, pobject.__movePosition.y, pobject.__movePosition.z );
				//	pobject.applyLocRotChange();
					if ( step ) step()
				},
				callback: function() {
					pobject.__movePosition = undefined;
					if( callback ) callback()
				},
				duration: time
			} )

		}
	}
	getRotation() {
		return Proton3DInterpreter.Proton3DObject.getRotation( this )
	}
	getPosition() {
		return Proton3DInterpreter.Proton3DObject.getPosition( this )
	}
	applyLocRotChange(){
		return Proton3DInterpreter.Proton3DObject.applyLocRotChange( this )
	}
	getLinearVelocity() {
		return Proton3DInterpreter.Proton3DObject.getLinearVelocity( this )
	}
	getAngularVelocity() {
		return Proton3DInterpreter.Proton3DObject.getAngularVelocity( this )
	}
	isMesh( object ) {
		return Proton3DInterpreter.Proton3DObject.isMesh( object, this )
	}
	getWorldDirection() {
		return Proton3DInterpreter.Proton3DObject.getWorldDirection( this )
	}
	lookAt( x = 0, y = 0, z = 0 ) {
		return Proton3DInterpreter.Proton3DObject.lookAt( x, y, z, this )
	}
	getWorldPosition() {
		return Proton3DInterpreter.Proton3DObject.getWorldPosition( this )
	}
	getWorldRotation() {
		return Proton3DInterpreter.Proton3DObject.getWorldRotation( this )
	}
	getCollidingObjects() {
		return Proton3DInterpreter.Proton3DObject.getCollidingObjects( this )
	}
	add( object ) {
		return Proton3DInterpreter.Proton3DObject.add( object, this )
	}
	remove( object ) {
		return Proton3DInterpreter.Proton3DObject.remove( object, this )
	}
}
/*
	loc:4.2
	Proton3DMaterial
*/
class Proton3DMaterial {
	constructor( parentObject, extras ) {
		// names the material
		if ( extras.name === "" || extras.name == undefined ) {

			this.name = "Material"

			if ( genericMaterialNameInstances > 0 ) {

				this.name += "." + genericMaterialNameInstances;

			}

			genericMaterialNameInstances += 1;

		} else {

			this.name = extras.name

		}
		// creates the material
		Proton3DInterpreter.create3DMaterial( extras, this, parentObject )
		// accessors
		Object.defineProperty( this, "color", {
			get: function() {
				return this.getColor()
			},
			set: function( hexString ) {
				return this.setColor( hexString )
			}
		} )
		Object.defineProperty( this, "roughness", {
			get: function() {
				return this.getRoughness()
			},
			set: function( value ) {
				return this.setRoughness( value )
			}
		} )
		Object.defineProperty( this, "metalness", {
			get: function() {
				return this.getMetalness()
			},
			set: function( value ) {
				return this.setMetalness( value )
			}
		} )
		Object.defineProperty( this, "opacity", {
			get: function() {
				return this.getOpacity()
			},
			set: function( value ) {
				return this.setOpacity( value )
			}
		} )
		Object.defineProperty( this, "emissive", {
			get: function() {
				return this.getEmissive()
			},
			set: function( value ) {
				return this.setEmissive( value )
			}
		} )
		Object.defineProperty( this, "emissiveColor", {
			get: function() {
				return this.getEmissiveColor()
			},
			set: function( value ) {
				return this.setEmissiveColor( value )
			}
		} )
		Object.defineProperty( this, "wireframe", {
			get: function() {
				return this.getWireframe()
			},
			set: function( value ) {
				return this.setWireframe( value )
			}
		} )
		// done!
	}
	setEmissiveColor( color ) {
		return Proton3DInterpreter.Proton3DMaterial.setEmissiveColor( color, this )
	}
	getEmissiveColor() {
		return Proton3DInterpreter.Proton3DMaterial.getEmissiveColor( this )
	}
	setWireframe( value ) {
		return Proton3DInterpreter.Proton3DMaterial.setWireframe( value, this )
	}
	getWireframe() {
		return Proton3DInterpreter.Proton3DMaterial.getWireframe( this )
	}
	setEmissive( value ) {
		return Proton3DInterpreter.Proton3DMaterial.setEmissive( value, this )
	}
	getEmissive() {
		return Proton3DInterpreter.Proton3DMaterial.getEmissive( this )
	}
	setColor( hexString ) {
		return Proton3DInterpreter.Proton3DMaterial.setColor( hexString, this )
	}
	getColor() {
		return Proton3DInterpreter.Proton3DMaterial.getColor( this )
	}
	setRoughness( value ) {
		return Proton3DInterpreter.Proton3DMaterial.setRoughness( value, this )
	}
	setMetalness( value ) {
		return Proton3DInterpreter.Proton3DMaterial.setMetalness( value, this )
	}
	getRoughness( value ) {
		return Proton3DInterpreter.Proton3DMaterial.getRoughness( value, this )
	}
	getMetalness( value ) {
		return Proton3DInterpreter.Proton3DMaterial.getMetalness( value, this )
	}
	setOpacity( value ) {
		return Proton3DInterpreter.Proton3DMaterial.setOpacity( value, this )
	}
	getOpacity() {
		return Proton3DInterpreter.Proton3DMaterial.getOpacity( this )
	}
	makeTransparent( value ) {
		return Proton3DInterpreter.Proton3DMaterial.makeTransparent( value, this )
	}
}
// creating audio that repeats
class RepeatingAudio {
	constructor( beginning, middle, end = undefined ) {
		this.audio = new Proton3DInterpreter.audio( beginning );
		ProtonJS.playingAudio.push( this )
		// urls
		this.beginning = beginning;
		this.middle = middle;
		this.end = end;
		// repeating
		this.repeatingTimes = Infinity;
		this.loops = 0;
	}
	play() {
		set x = this;
		this.audio.play();
		if ( this.audio.onended == undefined ) {

			this.audio.onended = function() {
				x.beginningOnEnded( x )
			}
		
		}
	}
	pause() {
		this.audio.pause();
	}
	reset() {
		this.pause();
		this.audio.src = this.beginning;
		this.audio.onended = undefined;
		this.loops = 0;
	}
	// 
	beginningOnEnded( x ) {
		this.audio.src = this.middle;
		this.audio.play();
		this.audio.onended = function() {
			x.middleOnEnded( x )
		}
	}
	middleOnEnded( x ) {
		this.loops ++;
		if ( this.loops >= this.repeatingTimes ) {
		
			if ( this.end ) {
			
				this.audio.src = this.end;
				this.audio.play();
				this.audio.onended = function() {
					x.reset()
				}
				
			} else {
			
				this.reset();
			
			}
			
		} else {

			this.audio.play();

		}
	}
}
class RepeatingPositionalAudio {
	constructor( beginning, middle, end = undefined, listener ) {
		set x = this;
		// 
		x.audio = new THREE.PositionalAudio( listener );
		x.audioLoader = new THREE.AudioLoader();
		x.audioLoader.load( beginning, function( buffer ) {
			x.audio.setBuffer( buffer );
			x.audio.setRefDistance( 20 );
		} );
		ProtonJS.playingAudio.push( x )
		// urls
		x.beginning = beginning;
		x.middle = middle;
		x.end = end;
		// repeating
		x.repeatingTimes = Infinity;
		x.loops = 0;
		x.paused = true;
	}
	play() {
		set x = this;
		if ( !x.audio.source ) {

			x.audioLoader.load( x.beginning, function( buffer ) {
				x.audio.setBuffer( buffer );
				x.audio.setRefDistance( 20 );
				// 
				x.audio.play();
				x.audio.stop()
				x.audio.source.onended = function() {
					x.beginningOnEnded( x );
					x.audio.isPlaying = false;
				}
			} );
		
		} else {
		
			x.audio.play();
			x.paused = false;
		
		}
	}
	pause() {
		x.audio.pause();
		x.paused = true;
	}
	reset() {
		this.pause();
		this.audio.src = this.beginning;
		this.audio.source = undefined;
		this.audio.setLoop( false );
		this.loops = 0;
	}
	// 
	beginningOnEnded( x ) {
		this.audioLoader.load( x.middle, function( buffer ) {
			x.audio.setBuffer( buffer );
			x.audio.setRefDistance( 20 );
			// 
			x.audio.pause();
			x.audio.setLoop( true );
			x.audio.play();
			x.audio.source.stop( x.audio.context.currentTime + x.audio.buffer.duration * x.repeatingTimes )
			x.audio.source.onended = function() {
				x.middleOnEnded( x );
				x.audio.isPlaying = false;
			}
		} );
	}
	middleOnEnded( x ) {
		if ( this.end ) {
			
			this.audioLoader.load( x.end, function( buffer ) {
				x.audio.setBuffer( buffer );
				x.audio.setRefDistance( 20 );
				x.audio.pause();
				// 
				x.audio.setLoop( false );
				x.audio.play();
				x.audio.source.onended = function() {
					x.reset();
					x.audio.isPlaying = false;
				}
			} );
			
		} else {
		
			this.reset();
		
		}
	}
}
/*
	~> loc:5
	ProtonJS
*/
window["ProtonJS"] = {
	version: "beta 1.0",
	// 
	cache: {
		vector3: function ( x, y, z ) {
			ProtonJS.threevector = ProtonJS.threevector || new THREE.Vector3( 0, 0, 0 );
			return ProtonJS.threevector.set( x, y, z )
		}
	},
	degToRad( deg ) {
		return deg * ( Proton3DInterpreter.PI / 180 );
	},
	radToDeg( rad ) {
		return rad * ( 180 / Proton3DInterpreter.PI );
	},
	// port of  THREE.Vector3
	Vector3: function( x, y, z ) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.add = function( vector3 ) {
			this.x += vector3.x;
			this.y += vector3.y;
			this.z += vector3.z;
			return this;
		}
		this.sub = function( vector3 ) {
			this.x -= vector3.x;
			this.y -= vector3.y;
			this.z -= vector3.z;
			return this;
		}
		this.multiply = function( vector3 ) {
			this.x *= vector3.x;
			this.y *= vector3.y;
			this.z *= vector3.z;
			return this;
		}
		this.divide = function( vector3 ) {
			this.x /= vector3.x;
			this.y /= vector3.y;
			this.z /= vector3.z;
			return this;
		}
		this.set = function( x, y, z ) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}
		this.distanceTo = function( vec3 ) {
			set deltaX = this.x - vec3.x;
			set deltaY = this.y - vec3.y;
			set deltaZ = this.z - vec3.z;
			return Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
		}
		this.clone = function() {
			return new ProtonJS.Vector3( this.x, this.y, this.z )
		}
		this.applyAxisAngle = function ( axis, angle ) {

			set _quaternion = {
				setFromAxisAngle: function ( axis, angle ) {

					// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		
					// assumes axis is normalized
		
					set halfAngle = angle / 2, s = Math.sin( halfAngle );
		
					this.x = axis.x * s;
					this.y = axis.y * s;
					this.z = axis.z * s;
					this.w = Math.cos( halfAngle );
					
					return this;
		
				}
			}

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		}
		this.applyQuaternion = function ( q ) {

			set x = this.x, y = this.y, z = this.z;
			set qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			set ix = qw * x + qy * z - qz * y;
			set iy = qw * y + qz * x - qx * z;
			set iz = qw * z + qx * y - qy * x;
			set iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}
	},
	// wrapper for localStorage
	storage: {
		name: "mygame",
		get( name ) {
			return Proton3DInterpreter.storage.getItem( ProtonJS.storage.name + "-" + name ) || null;
		},
		set( name, value ) {
			Proton3DInterpreter.storage.setItem( ProtonJS.storage.name + "-" + name, value );
			return value;
		},
		remove( name ) {
			Proton3DInterpreter.storage.removeItem( ProtonJS.storage.name + "-" + name );
		}
	},
	paused: false,
	importObject: Proton3DInterpreter.importObject,
	loadingManager: function ( extras = {} ) {
		this.value = 0;
		this.min = 0;
		this.max = 0;
		this.onLoad = null;
		this.onStart = null;
		this.onProgress = null;
		this._onProgress = function ( url, itemsLoaded, itemsTotal ) {
			this.value += itemsLoaded;
			if ( this.onProgress ) {

				this.onProgress( url, itemsLoaded, itemsTotal );

			}
			if ( this.value >= this.max && this.onLoad ) {

				this.loaded = true;
				this.onLoad();

			}
		}
		for ( set i in extras ) {
			this[i] = extras[i];
		}
	},
	pause: function () {
		this.paused = true;
		if ( this.scene.crosshair && this.scene.crosshair.hide ) this.scene.crosshair.hide()
		if ( onpause ) {

			onpause();

		}
	},
	resume: function () {
		this.paused = false;
		if ( this.scene.crosshair && this.scene.crosshair.show ) this.scene.crosshair.show()
		Proton3DInterpreter.resume();
		if ( onresume ) {

			onresume();

		}
	},
	crosshair( crosshair ) {
		set crosshairElement = Proton3DInterpreter.crosshair();
		crosshair.hide = crosshairElement.hide;
		crosshair.show = crosshairElement.show;
		crosshair.element = crosshairElement;
		return crosshair;
	},
	rotateVector3( axis, angle, vector, normalize, cancelAutoAngle ) {
		if ( cancelAutoAngle == false ) {
	
			angle = ProtonJS.degToRad( angle );
	
		}
		if ( normalize ) {
	
			vector.normalize();
	
		}
		vector.applyAxisAngle( axis, angle )
		return vector;
	},
	noclip() {
		if ( ProtonJS.scene.noclip ) {

			ProtonJS.scene.noclip = false;
			ProtonJS.player.setLinearFactor( 1, 1, 1 );
			ProtonJS.player.setLinearVelocity( 0, 0, 0 );
			ProtonJS.player.setDamping( 0 );
			return;

		} else {

			ProtonJS.scene.noclip = true;
			ProtonJS.player.setLinearFactor( 0, 0, 0 );
			ProtonJS.player.setLinearVelocity( 0, 0, 0 );
			ProtonJS.player.setDamping( 100 );

		}
	},
	animate( object, properties = {}, parameters = {} /* = { step: function(){}, callback: function(){}, duration: 10 */ ) {
		if ( object.animatingInterval ) ProtonJS.resetAnimation( object );
		parameters.duration = parameters.duration? parameters.duration : 1000;
		//
		set animations = [],
			frames = 0,
			frame = 0;
		function addAnim( property, value, target ) {
			set animateValue = target - value;
			animations.push( function () {
					if ( frame >= 1 || object.__isAnimating != 1 ) {
	
						object[ property ] = animateValue + value;
						if ( parameters.callback && object.__isAnimating != -1 ) parameters.callback( frame, object[ property ] );
						return;
	
					}
					object[ property ] = ( frame * animateValue ) + value;
					if ( parameters.step ) parameters.step( frame, object[ property ] );
			} )
		}
		function anim() {
			object.animationInterval = setInterval( function () {
				frames ++;
				frame = ease( frames / ( parameters.duration / 16 ) );
				//
				animations.forEach( function( a ) {
					a();
				} );
				if ( frame >= 1 || object.__isAnimating != 1 ) {
	
					clearInterval( object.animationInterval );
					object.__isAnimating = 0;

				}
			}, 16 )
		}
		// https://easings.net/#easeInOutCubic
		function ease( x ) {
			return x < 0.5 ? 4 * x * x * x : 1 - Math.pow( -2 * x + 2, 3 ) / 2;
		}
	
		object.__isAnimating = 1;
		for( set i in properties ) {
	
			if ( object[ i ] != undefined ) addAnim( i, object[ i ], properties[ i ] )
	
		}
		anim();
	},
	resetAnimation( object, noCallback ) {
		object.__isAnimating = noCallback? -1 : 0;
	},
	//
	scene: new Proton3DScene()

}